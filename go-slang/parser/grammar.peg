Sequence
    = Block
    / __ a:Block __ b:Sequence  { return [a].concat(b).filter(x=>x!=null) }
    / __ a:IfStatement __ b:Sequence {return [a].concat(b).filter(x=>x!=null)}
    / __ a:Statement __ EOS __ b:Sequence { return [a].concat(b).filter(x=>x!=null) }
    / a:Statement? { return a }

Statement 
    = Block
    / IfStatement 
    / NameDeclaration
    / Expression 

Block
    = "{" __ body:(Sequence)? "}" {
        return {
            tag: "blk",
            body: { tag: "seq", stmts: body },
        }
    }

IfStatement 
    = IfToken __ pred:Expression __ cons:Block altBlk:(__ ElseToken __ alt: Block {return alt})|0..1| {
      let processedAlt;
      altBlk = altBlk[0];
      if (altBlk) {
        processedAlt = altBlk.body;
      } else {
        processedAlt = { tag: "seq", stmts: [] }
      }
      return {
          tag : "cond",
          pred: pred,
          cons: cons.body,
          alt: processedAlt
      }
    }

NameDeclaration "name declaration"
    = ConstantDeclaration
    / VariableDeclaration
    / ShortDeclaration

ConstantDeclaration "const declaration"
    = ConstToken __ symbol:Identifier __ "=" !"=" __ expression:Expression   {
        return {
            tag: "const",
            sym: symbol,
            expr: expression,
        }
    }

VariableDeclaration "var declaration"
    = VarToken __ symbol:Identifier __ "=" !"=" __ expression:Expression   {
        return {
            tag: "var",
            sym: symbol,
            expr: expression,
        }
    }

ShortDeclaration "short var declaration"
    = symbol:Identifier __ ShortAssmt __ expression:Expression {
        return {
          tag: "var",
          sym: symbol,
          expr: expression,
        }
    }

Expression
    = BinaryExpression
    / UnaryExpression
    / CallExpression
    / PrimaryExpression

BinaryExpression
    = e1:UnaryExpression __ symbol:BinaryOperator __ e2:BinaryExpression {
        return {
            tag: "binop",
            sym: symbol,
            first: e1,
            second: e2
        }
    }
    / UnaryExpression

UnaryExpression
    = op:UnaryOperator __ e:UnaryExpression {
        return {
            tag: "unop",
            sym: op,
            expr: e
        }
    }
    / CallExpression

CallExpression
    = fn:PrimaryExpression __ args:Arguments {
        return { tag: "app", fun: fn, args: args }
    }
    / PrimaryExpression

PrimaryExpression
    = Literal
    / ident:Identifier { return { tag: "nam", sym: ident } }
    / "(" __ expr:Expression __ ")" { return expr }

Arguments
    = "(" __ exprs:ExpressionList __ ")" { return exprs }

ExpressionList
    = expr:Expression exprs:( __ "," __ $ Expression )* {
        return [expr].concat(exprs)
    }

//In principle should be unicode letter and unicode digit
Identifier
    = $ ( letter ( letter / DecimalDigit )*) 

//Added DecimalLiteral
Literal
  = NullLiteral
  / BooleanLiteral
  / DecimalLiteral

NullLiteral
  = NullToken { return { tag: "Literal", value: null }; }

BooleanLiteral
  = TrueToken  { return { tag: "Literal", value: true  }; }
  / FalseToken { return { tag: "Literal", value: false }; }


DecimalLiteral
  = DecimalIntegerLiteral "." DecimalDigit* ExponentPart? {
      return { tag: "Literal", value: parseFloat(text()) };
    }
  / "." DecimalDigit+ ExponentPart? {
      return { tag: "Literal", value: parseFloat(text()) };
    }
  / DecimalIntegerLiteral ExponentPart? {
      return { tag: "Literal", value: parseFloat(text()) };
    }

DecimalIntegerLiteral
  = "0"
  / NonZeroDigit DecimalDigit*

DecimalDigit
  = [0-9]

NonZeroDigit
  = [1-9]

ExponentPart
  = ExponentIndicator SignedInteger

ExponentIndicator
  = "e"i

SignedInteger
  = [+-]? DecimalDigit+

HexDigit
  = [0-9a-f]i

letter            "letter"                      
  = [a-zA-ZáàâäãåçéèêëíìîïñóòôöõúùûüýÿæœÁÀÂÄÃÅÇÉÈÊËÍÌÎÏÑÓÒÔÖÕÚÙÛÜÝŸÆŒ]
  / "_"

//Simplified IdentifierPart 
IdentifierPart
  = IdentifierStart

//Simplified IdentifierStart
IdentifierStart
  = "$"
  / "_"
  / "\\" 

// Tokens

BreakToken      = "break"      !IdentifierPart
CaseToken       = "case"       !IdentifierPart
CatchToken      = "catch"      !IdentifierPart
ClassToken      = "class"      !IdentifierPart
ConstToken      = "const"      !IdentifierPart
ContinueToken   = "continue"   !IdentifierPart
DebuggerToken   = "debugger"   !IdentifierPart
DefaultToken    = "default"    !IdentifierPart
DeleteToken     = "delete"     !IdentifierPart
DoToken         = "do"         !IdentifierPart
ElseToken       = "else"       !IdentifierPart
EnumToken       = "enum"       !IdentifierPart
ExportToken     = "export"     !IdentifierPart
ExtendsToken    = "extends"    !IdentifierPart
FalseToken      = "false"      !IdentifierPart
FinallyToken    = "finally"    !IdentifierPart
ForToken        = "for"        !IdentifierPart
FunctionToken   = "function"   !IdentifierPart
GetToken        = "get"        !IdentifierPart
IfToken         = "if"         !IdentifierPart
ImportToken     = "import"     !IdentifierPart
InstanceofToken = "instanceof" !IdentifierPart
InToken         = "in"         !IdentifierPart
NewToken        = "new"        !IdentifierPart
NullToken       = "null"       !IdentifierPart
ReturnToken     = "return"     !IdentifierPart
SetToken        = "set"        !IdentifierPart
SuperToken      = "super"      !IdentifierPart
SwitchToken     = "switch"     !IdentifierPart
ThisToken       = "this"       !IdentifierPart
ThrowToken      = "throw"      !IdentifierPart
TrueToken       = "true"       !IdentifierPart
TryToken        = "try"        !IdentifierPart
TypeofToken     = "typeof"     !IdentifierPart
VarToken        = "var"        !IdentifierPart
VoidToken       = "void"       !IdentifierPart
WhileToken      = "while"      !IdentifierPart
WithToken       = "with"       !IdentifierPart


LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029" 

__
  = (WhiteSpace / LineTerminatorSequence)*


WhiteSpace "whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"
  / Zs

// Separator, Space
Zs = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

EOS
  = __ ";"

ShortAssmt      
  = ":="

UnaryOperator
  = $DeleteToken
  / $VoidToken
  / $TypeofToken
  / "++"
  / "--"
  / $("+" !"=")
  / $("-" !"=")
  / "~"
  / "!"

BinaryOperator
  = $("+" ![+=])
  / $("-" ![-=])
