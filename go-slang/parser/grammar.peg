//Convenience Functions
{
  function buildBinaryExpression(head, tail) {
    return tail.reduce(function(result, element) {
      return {
        tag: "binop",
        sym: element[1],
        first: result,
        second: element[3]
      };
    }, head);
  }
}

Sequence
    = Block
    / __ a:Block __ b:Sequence  { return [a].concat(b).filter(x=>x!=null) }
    // TODO: is this correct?
    / __ a:FunctionStatement __ b:Sequence {return [a].concat(b).filter(x=>x!=null)}
    / __ a:IfStatement __ b:Sequence {return [a].concat(b).filter(x=>x!=null)}
    / __ a:LoopStatement __ b:Sequence {return [a].concat(b).filter(x=>x!=null)}
    / __ a:Statement __ EOS __ b:Sequence { return [a].concat(b).filter(x=>x!=null) }
    / a:Statement? { return a }

Statement 
    = Block
    / IfStatement
    / LoopStatement
    / ReturnStatement
    / NameDeclaration
    / FunctionStatement
    / GoStatement
    / Expression 

FunctionStatement 
  = FunctionDeclaration 
  / MethodDeclaration

FunctionDeclaration =
    FunctionToken __ symbol:Identifier __ "(" __ params:ExpressionList __ ")" __ body: Block {
        return {
            tag: "fun",
            sym: symbol,
            prms: params.map(x => x.sym),
            body,
        }
    }

MethodDeclaration = 
    FunctionToken __ "(" __ receiver:Identifier __ ")" __ symbol:Identifier __ "(" __ params:ExpressionList __ ")" __ body: Block {
        return {
            tag: "fun",
            sym: symbol,
            prms: [receiver].concat(params.map(x => x.sym)),
            body,
        }
    }

ReturnStatement =
    ReturnToken __ exp:Expression { return {tag : "ret", expr : exp} }

Block
    = "{" __ body:(Sequence)? "}" {
        return {
            tag: "blk",
            body: { tag: "seq", stmts: body },
        }
    }

LoopStatement "loops"
  = WhileStatement

SimpleStatement
    = NameDeclaration
    / Expression

WhileStatement "while statement" //while is not used in Golang
  = ForToken __
      init:SimpleStatement? __ SEMICOLON __ 
      pred:Expression? __ SEMICOLON __
      post:SimpleStatement? __
    body:Block 
    {
      let while_object;
      //If there is no predicate, the predicate is true (infinite loop)
      if (pred) {
        while_object = {tag : "while", pred, body};
      } else {
        const true_object = {"tag": "lit", "val": true};
        while_object = {tag : "while", pred : true_object, body};
      }
      //the post statement is to be executed at the end of the loop, if it is executed
      if (post) {
        //deal with empty bodies
        if (while_object.body.body.stmts === null) {
          while_object.body.body.stmts = [post];
        } else {
          while_object.body.body.stmts.push(post);
        }
      }
      //the init is executed once before evaluating the condition
      if (init) {
        //The variable has to be initialized within its own block
        let body_array = [init, while_object];
        return {
            tag: "blk",
            body: { tag: "seq", stmts: body_array },
        }
      } else {
        return while_object;
      }
    }
  / ForToken __ pred:Expression __ body:Block {
      return {
        tag : "while",
        pred,
        body
      }
    }


IfStatement 
    = IfToken __ pred:Expression __ cons:Block altBlk:(__ ElseToken __ alt: Block {return alt})|0..1| {
        let processedAlt;
        altBlk = altBlk[0];
        if (altBlk) {
          processedAlt = altBlk.body;
        } else {
          processedAlt = { tag: "seq", stmts: [] }
        }
        return {
            tag : "cond",
            pred: pred,
            cons: cons.body,
            alt: processedAlt
        }
    }

NameDeclaration "name declaration"
    = ConstantDeclaration
    / VariableDeclaration
    / ShortDeclaration

ConstantDeclaration "const declaration"
    = ConstToken __ symbol:Identifier __ Assmt __ expression:Expression   {
        return {
            tag: "const",
            sym: symbol,
            expr: expression,
        }
    }

VariableDeclaration "var declaration"
    = VarToken __ symbol:Identifier __ Assmt __ expression:Expression   {
        return {
            tag: "var",
            sym: symbol,
            expr: expression,
        }
    }

ShortDeclaration "short var declaration"
    = symbol:Identifier __ ShortAssmt __ expression:Expression {
        return {
          tag: "var",
          sym: symbol,
          expr: expression,
        }
    }

GoStatement "go statement"
    = "go" __ call:CallExpression {
        return {
            ...call,
            // TODO: handle in VM
            go: true,
        }
    }

Expression
    = VariableAssignment
    / BinaryExpression
    / UnaryExpression
    / CallExpression
    / PrimaryExpression

MultiplicativeExpression
  = head:UnaryExpression 
    tail:(__ mul_op __ UnaryExpression)*
    { return buildBinaryExpression(head, tail); }
  / UnaryExpression

AdditiveExpression
  = head:MultiplicativeExpression
    tail:(__ add_op __ MultiplicativeExpression)*
    { return buildBinaryExpression(head, tail); }
  / MultiplicativeExpression

BinaryExpression
  = head:AdditiveExpression
    tail:(__ rel_op __ AdditiveExpression)*
    { return buildBinaryExpression(head, tail); }
  / AdditiveExpression

UnaryExpression
    = op:UnaryOperator __ e:UnaryExpression {
        return {
            tag: "unop",
            sym: op,
            expr: e
        }
    }
    / CallExpression
  
VariableAssignment "assignment"
  = symbol:Identifier __ Assmt __ exp:Expression { 
    return {
      tag : 'assmt',
      sym : symbol,
      expr : exp
    } 
  }

CallExpression
    = FunctionCall
    / MethodCall
    / PrimaryExpression

FunctionCall
  = fn:PrimaryExpression __ args:Arguments {
        return { tag: "app", fun: fn, args: args }
    }

MethodCall
  = obj:NameExpression DOT fn:PrimaryExpression __ args:Arguments {
        return { tag: "app", fun: fn, args: [obj].concat(args) }
    }

PrimaryExpression
    = Literal
    / NameExpression
    / "(" __ expr:Expression __ ")" { return expr }

NameExpression
  = ident:Identifier { return { tag: "nam", sym: ident } }

Arguments
    = "(" __ exprs:ExpressionList __ ")" { return exprs }

ExpressionList
    = expr:Expression exprs:( __ "," __ exp:Expression {return exp})* {
        return [expr].concat(exprs).filter(x=>x!=null)
      }
    / expr:Expression? {return [expr].filter(x => x!=null)}


//In principle should be unicode letter and unicode digit
Identifier
    = !ReservedWord ident:$( letter ( letter / DecimalDigit )* ) {return ident}

//Added DecimalLiteral
Literal
  = NullLiteral
  / BooleanLiteral
  / DecimalLiteral
  / StringLiteral

//Strings
StringLiteral "string"
  = DQUO chars:(!LineTerminatorSequence [^"])* DQUO {
      return { tag: "Literal", value: chars.join("") };
    }
  / BQUO chars:([^`])* BQUO {
      return { tag: "Literal", value: chars.join("") };
    }
  / SQUO chars:([^']) SQUO {
      return { tag : "Literal", value : chars.charCodeAt(0)}
  }

NullLiteral
  = NullToken { return { tag: "Literal", value: null }; }

BooleanLiteral
  = TrueToken  { return { tag: "Literal", value: true  }; }
  / FalseToken { return { tag: "Literal", value: false }; }


DecimalLiteral
  = DecimalIntegerLiteral "." DecimalDigit* ExponentPart? {
      return { tag: "Literal", value: parseFloat(text()) };
    }
  / "." DecimalDigit+ ExponentPart? {
      return { tag: "Literal", value: parseFloat(text()) };
    }
  / DecimalIntegerLiteral ExponentPart? {
      return { tag: "Literal", value: parseFloat(text()) };
    }

DecimalIntegerLiteral
  = "0"
  / NonZeroDigit DecimalDigit*

DecimalDigit
  = [0-9]

NonZeroDigit
  = [1-9]

ExponentPart
  = ExponentIndicator SignedInteger

ExponentIndicator
  = "e"i

SignedInteger
  = [+-]? DecimalDigit+

HexDigit
  = [0-9a-f]i

letter            "letter"                      
  = [a-zA-ZáàâäãåçéèêëíìîïñóòôöõúùûüýÿæœÁÀÂÄÃÅÇÉÈÊËÍÌÎÏÑÓÒÔÖÕÚÙÛÜÝŸÆŒ]
  / "_"

//Simplified IdentifierPart 
IdentifierPart
  = IdentifierStart

//Simplified IdentifierStart
IdentifierStart
  = "$"
  / "_"
  / "\\"      

// Tokens

BreakToken      = "break"      !IdentifierPart
CaseToken       = "case"       !IdentifierPart
CatchToken      = "catch"      !IdentifierPart
ClassToken      = "class"      !IdentifierPart
ConstToken      = "const"      !IdentifierPart
ContinueToken   = "continue"   !IdentifierPart
DebuggerToken   = "debugger"   !IdentifierPart
DefaultToken    = "default"    !IdentifierPart
DoToken         = "do"         !IdentifierPart
ElseToken       = "else"       !IdentifierPart
EnumToken       = "enum"       !IdentifierPart
ExportToken     = "export"     !IdentifierPart
ExtendsToken    = "extends"    !IdentifierPart
FalseToken      = "false"      !IdentifierPart
FinallyToken    = "finally"    !IdentifierPart
ForToken        = "for"        !IdentifierPart
FunctionToken   = "func"       !IdentifierPart
GetToken        = "get"        !IdentifierPart
IfToken         = "if"         !IdentifierPart
ImportToken     = "import"     !IdentifierPart
InstanceofToken = "instanceof" !IdentifierPart
InToken         = "in"         !IdentifierPart
NewToken        = "new"        !IdentifierPart
NullToken       = "null"       !IdentifierPart
ReturnToken     = "return"     !IdentifierPart
SetToken        = "set"        !IdentifierPart
SuperToken      = "super"      !IdentifierPart
SwitchToken     = "switch"     !IdentifierPart
ThisToken       = "this"       !IdentifierPart
ThrowToken      = "throw"      !IdentifierPart
TrueToken       = "true"       !IdentifierPart
TryToken        = "try"        !IdentifierPart
VarToken        = "var"        !IdentifierPart
WithToken       = "with"       !IdentifierPart

Tokens "tokens"
  = BreakToken 
  / CaseToken       
  / CatchToken      
  / ClassToken      
  / ConstToken      
  / ContinueToken   
  / DebuggerToken   
  / DefaultToken   
  / DoToken         
  / ElseToken       
  / EnumToken       
  / ExportToken     
  / ExtendsToken    
  / FalseToken      
  / FinallyToken    
  / ForToken      
  / FunctionToken   
  / GetToken        
  / IfToken         
  / ImportToken     
  / InstanceofToken 
  / InToken         
  / NewToken        
  / NullToken       
  / ReturnToken     
  / SetToken        
  / SuperToken      
  / SwitchToken     
  / ThisToken       
  / ThrowToken      
  / TrueToken       
  / TryToken        
  / VarToken           
  / WithToken  

ReservedWord "reserved word"
  = Tokens

//Special Symbols
DOT
  = "."
SEMICOLON
  = ";"

//Quotes
DQUO              "double quote"                
  = "\u0022"        // ""
SQUO              "single quote"                
  = "\u0027"        // ''
BQUO              "back quote/grave accent"     
  = "\u0060"        // ``

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029" 

__
  = (WhiteSpace / LineTerminatorSequence)*


WhiteSpace "whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"
  / Zs

// Separator, Space
Zs = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

EOS
  = __ ";"

//Binary Operators

mul_op          "multiplication operator"       
  = "*"
  / "/"
  / "%"

add_op          "addition operator"             
  = $("+" ![+=])
  / $("-" ![-=])

rel_op          "comparison operator"           
  = "=="           
  / "!="
  / "<="
  / ">="
  / "<"
  / ">"

Assmt
  = "=" !"="

ShortAssmt      
  = ":="

UnaryOperator
  = $("+" !"=")
  / $("-" !"=")
  / "!"
